《深入浅出Node.js》阅读总结

## 内存控制

### 1.V8的垃圾回收与内存限制

Node是一个构建在Chrome的JS运行时上的平台。在Node中通过JS使用内存时只能使用部分内存。在Node中使用的JS对象基本上都是通过V8自己的方式来进行分配和管理的。

V8堆内存大小的限制，对内存泄漏很敏感。

在V8中，所有的JS对象都是通过堆来分配的。下面的代码可以查看内存信息：

```
$ node
> process.memoryUsage()
{ rss: 23056384,
  heapTotal: 9682944, //已申请到的堆内存
  heapUsed: 5510856,  //已使用的堆内存
  external: 8821 }
```

**V8为何要限制堆大小？**

原因是V8的垃圾回收机制的限制。如果内存较大，则垃圾回收的时间耗费较久，会引起JS线程暂停执行，应用的性能和响应能力直线下降。

使用--max-old-space-size或--max-new-space-size可以调整内存限制的大小。

**V8的垃圾回收机制有哪些？**

V8的垃圾回收策略主要基于分代式垃圾回收机制。在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。

```
--max-old-space-size   //设置老生代生存空间的最大值
--max-new-space-size  //设置新生代内存空间的最大值
```

当内存空间超过设置的最大值时，进程就会出错。

1）Cheney算法

在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在具体实现中，采用Cheney算法。

Cheney算法采用复制的方法实现垃圾回收，它将堆内存一分为二，每个空间叫semispace，处于使用中的semispace称为From空间，闲置状态的semispace称为To空间。分配对象时，先在From空间分配，当进行垃圾回收时，会检查From空间的存活对象，然后这些存活对象被复制在To空间中，非存活对象所占用的空间释放。完成复制后，From空间和To空间的角色对换。

总之，在垃圾回收的过程中，通过将两个存活对象在两个semispace空间之间进行复制。牺牲空间换时间。适用于生命周期较短的新生代中。


在分代式垃圾回收的前提下，From空间中的对存活对象在复制到To空间之前需要进行检查，需要将存活周期长的对象移动到老生代中，完成对象晋升。

对象晋升的两个条件：一个是对象是否经历过Scavenge回收；一个是To空间的内存占用比超过限制。

缺点：浪费一半空间；存活对象较多，复制存活对象效率较低。

2）Mark-Sweep & Mark-Compact

Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。适用于死对象较少的老生代中。

Mark-compact是在Mark-Sweep基础上演变而来的。差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。

V8主要使用Mark-Sweep,在空间不足以对从新生代中晋升过来的对象进行分配时才适用Mark-Compact。

3）Incremental Marking

为了避免Js应用逻辑与垃圾回收器看到的不一致情况，垃圾回收的三种算法都需要将应用逻辑停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为叫“全停顿”。

为了降低全堆垃圾回收带来的停顿时间，V8在标记阶段将原本一口气停顿完成的的动作改为增量标记，拆分为多个小“步进”，使垃圾回收与应用逻辑交替执行直到标记阶段完成。

### 2. 高效使用内存

1）作用域

在JS中，能形成作用域的有函数调用，with,以及全局作用域。

如果变量是全局变量，由于全局作用域需要直到进程退出才能释放，会导致引用的对象常驻在老生代内存中。释放常驻内存的对象，有两个方法：

1.通过delete操作删除引用关系。

2.变量重新复制，让旧的对象脱离引用关系。

```
global.foo = 'global foo';
delete global.foo;  //通过delete操作符解除引用关系

//或者重新赋值
global.foo = undefined;  //or null
```

V8中通过delete删除对象的属性有可能干扰V8的优化，所以通过赋值的方式解除引用会更好。

2）闭包

闭包内可以访问外部的变量，外部不能访问闭包内的变量。

使用闭包将会导致闭包所在的作用域不会释放，作用域产生的内存也不会释放。

3）小结

在JS执行中，无法立即回收的内存有全局变量和闭包引用两种情况。会导致老生代内存中的对象增加。


### 3. 内存指标

1）查看内存指标，单位是字节

```
$ node
> process.memoryUsage()
{ rss: 23056384,  //进程的常驻内存
  heapTotal: 9682944, //已申请到的堆内存
  heapUsed: 5510856,  //已使用的堆内存
  external: 8821 
}
```


进程的内存：一部分是rss, 其余部分在交换区（swap）或者文件系统（filesystem）中。


```
> os.totalmem()   //操作系统的总内存，单位字节
8589934592
> os.freemem()  //操作系统的闲置内存，单位字节
123162624
```

2）堆外内存

heapTotal小于rss值，意味着Node中的内存并非都是V8分配的。不通过V8分配的内存叫堆外内存。

Buffer对象不经过V8的内存分配机制，利用堆外内存可以突破内存限制的问题。

3）小结

Node的内存构成主要是通过V8分配的部分和Node自行分配的部分。受V8垃圾回收限制的主要是V8的堆内存heapTotal。



### 4. 内存泄漏

内存泄漏的实质是应当回收的对象出现意外而没有被回收，变成了常驻老生代的对象。造成内存泄漏的原因：

1.缓存

2.队列消费不及时

3.作用域未释放

**1）慎将内存当做缓存**

缓存的对象会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，会导致垃圾回收在扫描和整理时对这些对象做无用功。使用缓存限制时需注意以下几点：

1.限制缓存键值的数量

2.限制缓存大小

3.进程之间无法共享内存，如果在进程中使用缓存，可能会导致缓存内容重复。所以采用进程外的缓存，进程自身不存储状态。市面上较好的缓存有Redis和Memcached。

**2）关注队列状态**

1.监控队列长度，一旦堆积，通过监控系统产生报警并通知相关人员。

2.任何异步调用都需要包含超时机制。

### 5. 内存泄漏排查

进行堆内存的分析，可以借助下面两个工具。

1）node-heapdump

2）node-memwatch


### 6. 大内存应用

Node通过stream模块处理大文件。stream模块继承自EventEmitter。由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件的操作，改用fs.createReadStream()和fs.createWriteStream()通过流的方式实现对大文件的操作。

```
var reader = fs.createReadStream('in.txt');
var writer = fs.createWriteStream('out.txt');
reader.pipe(writer);  //pipe方法封装了data事件和写入操作
```

通过流的方式，代码不会受到V8内存的限制，有效提高程序的健壮性。



